# Turma 725, Equipe 3:
# Marjorie Luize Martins Costa, RA: 24223084-5;
# Matheus Ferreira de Freitas, RA: 24123080-4;
# Henrique Hodel Babler, RA: 24123079-6

# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣼⣿⣿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⣷⣿⣇⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⢰⣾⣿⣿⡟⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⣿⣿⣿⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⣠⣿⡿⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠿⣿⣧⣀⣤⣠⣄⣤⣀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⢰⣶⣿⡟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢙⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀⠀
# ⠀⢠⣼⣿⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠂⠁⠀⠘⣿⣿⡇⠀⠀⠀⠀
# ⢀⣸⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⢩⠁⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀
# ⣿⣿⣯⠀⠀⠀⣤⣴⣶⣶⣤⣦⢀+

#⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣴⣶⣴⣦⡆⣼⣿⢘⠀⠀⠀⢰⣿⣿⡇⠀⠀⠀⠀
# ⣿⣿⣟⠐⠀⣿⡏⠉⠈⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⠏⠉⢩⣿⣿⣿⣿⡿⢆⣰⣿⣿⣿⣿⣿⣷⣷⣀⠀⠀
# ⣿⣿⣿⢤⠀⣿⣷⣤⣤⣿⣿⣿⣿⢨⣶⣴⣶⣶⣶⣶⣶⣶⣿⣿⣦⣤⣼⣿⣿⣿⣏⡓⠸⣿⡟⡛⠛⠛⣛⣿⣿⣿⠀⢀
# ⠀⢸⣿⣿⣶⡹⡏⠀⠁⠈⠀⠹⠿⠘⣿⣧⣀⣀⣠⣀⣼⣿⠃⠿⠏⠩⢡⣼⣿⡿⠟⣿⣿⠋⠅⠀⠀⠀⠀⠀⢹⣿⣿⣿
# ⠀⠈⢹⣿⣶⡇⠀⠀⠀⠀⠀⠀⠀⠀⠙⣻⣿⣿⣿⣿⣟⠉⠀⠀⠀⢰⣶⣿⣿⡇⠄⠈⣿⠁⠀⠀⠀⠀⠀⠀⢸⣿⣿⡇
# ⠀⠀⠘⠛⣿⣿⣧⢅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣼⣿⠒⠛⠇⠀⠀⠀⠤⡀⠀⠀⠀⠀⠀⢸⣿⣿⡇
# ⠀⠀⠀⠀⠉⠿⢿⣿⣶⣐⣆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡏⢉⣁⠀⢨⣄⢀⠀⠀⢁⣀⣀⣀⣀⣀⣸⣿⣿⣷
# ⠀⠀⠀⠀⠀⠀⠘⠛⣿⣿⣿⣽⣿⣤⠤⡤⣤⢤⣤⡤⣤⣤⣤⣷⣿⡇⠀⠸⠀⠛⢻⣿⣴⣤⡄⣐⢸⣦⣿⣿⣿⣿⠛⠻
# ⠀⠀⠀⠀⠀⠀⠀⠀⠉⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⠽⣄⣀⣸⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠈⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠠⣶⣿⡟⣛⠉⠛⡟⣛⣛⠛⠛⠛⠛⠛⣻⢻⣿⣿⣿⣶⣾⣶⣿⣿⣿⡋⠋⠙⠋⠙⠋⠁⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⡟⠀⢈⣿⠇⠂⠀⠀⠀⠀⠀⠀⠀⠛⣿⣿⣿⣿⠿⠿⠿⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠉⢿⣷⣷⣾⣿⠀⠀⠀⢒⣶⣶⡖⡢⠀⠀⣿⣿⣿⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢻⣿⣿⣦⡄⠀⢰⣿⣿⣇⢱⠀⣤⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⡿⠏⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠛⠀⠀⠘⠛⠛⠛⠃⠀⠀⠀⠀⠀

import os
import tkinter as tk
from scipy.integrate import quad
from math import sqrt, pi, sin
from tkinter import messagebox
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy.integrate import quad

# Configuração inicial: Janela principal e declaração de variáveis e constantes
janela = tk.Tk()
janela.title("Menu")

frame_entrada = None
frame_saida = None

# Variáveis Gerais
hj = 6.626 * (10 ** -34)  # Constante de Planck em J.s
hev = 4.136 * (10 ** -15)  # Constante de Planck em eV.s
c = 3 * 10 ** 8  # Velocidade da luz no vácuo em m/s

l = 0  # Largura da caixa
ni = 0  # n inicial da partícula
nf = 0  # n final da partícula
n = 0 

# Probabilidade de encontrar a partícula entre a e b P(a <= x <= b) = 2/l * sin(n * pi * x / l) ** 2 (Integral)

a = 0  # Limite inferior para probabilidade
b = 0  # Limite superior para probabilidade
k = 0  # Número de onda em metros
xp = 0  # Posição x em metros

# Variável de controle de massa
m = 1.67 * (10 ** -27)  # Inicializando como próton

# Funções

# Função para calcular a energia inicial
def ei_j():
    ei = ni ** 2 * (hj ** 2) / (8 * m * l ** 2)
    return ei

# Função para calcular a energia final
def ef_j():
    ef = nf ** 2 * (hj ** 2) / (8 * m * l ** 2)
    return ef

# Função para calcular a energia final em eV
def e_f():
    efoton = abs(ef_ev() - ei_ev())
    return efoton

# Função para calcular a energia inicial em eV
def ei_ev():
    eij = ei_j() / (1.602 * (10 ** -19))
    return eij

# Função para calcular a energia final em eV
def ef_ev():
    efj = ef_j() / (1.602 * (10 ** -19))
    return efj

# Função para calcular o comprimento de onda
def lamb():
    lamb = (hev * 3 * (10 ** 8)) / e_f()
    return lamb

# Função para calcular a frequência
def freq():
    f = e_f() / hev
    return f

# Função para calcular a velocidade inicial
def vi():
    vi = sqrt((2 * ei_j()) / m)
    return vi

# Função para calcular a velocidade final
def vf():
    vf = sqrt((2 * ef_j()) / m)
    return vf

# Função para calcular o comprimento de onda inicial
def ci():
    ci = 2 * l / ni
    return ci

# Função para calcular o comprimento de onda final
def cf():
    cf = 2 * l / nf
    return cf

# Função para calcular o número de onda inicial
def ki():
    ki = ni * pi / l
    return ki

# Função para calcular o número de onda final
def kf():
    kf = nf * pi / l
    return kf

# Função para calcular a amplitude
def l_func():
    l = 2 / a ** 2
    return l

# Função para calcular o número de onda
def n_func():
    n = round((k * l) / pi)
    return n

# Verificar 
def probabilidade(a, b, ni, l):
    integrand = lambda x: 2 / l * sin((ni * pi * x) / l) ** 2
    result, _ = quad(integrand, a, b)
    return result

def probalidade_2():
    prob = 2 / l * (sin(n * pi * xp) ** 2)
    return prob

# Função para limpar frames
def limpar_frames():
    global frame_entrada, frame_saida
    if frame_entrada:
        frame_entrada.destroy()
    if frame_saida:
        frame_saida.destroy()

def m_option(opcao):
    global m
    if opcao == "1":
        m = 1.67 * (10 ** -27)  # massa do próton
    elif opcao == "2":
        m = 9.11 * (10 ** -31)  # massa do elétron
    else:
        print("Opção inválida. Tente novamente.")


# Esta função foi criada para consolidar e simplificar a criação de labels e entradas(mta label slc)

def labels_and_entries(parent):
    global entrada_l, entrada_ni, entrada_nf, entrada_a, entrada_b
    entrada_l = tk.Entry(parent)

    tk.Label(parent, text="Largura da caixa (L) em m:").grid(row=3, column=0)
    entrada_l.grid(row=3, column=1)

    entrada_ni = tk.Entry(parent)
    tk.Label(parent, text="n inicial da particula (Ni):").grid(row=4, column=0)
    entrada_ni.grid(row=4, column=1)

    entrada_nf = tk.Entry(parent)
    tk.Label(parent, text="n final da particula (Nf):").grid(row=5, column=0)
    entrada_nf.grid(row=5, column=1)

    tk.Label(parent, text="Dados para probabilidade:\n P(a <= x <= b)").grid(row=6, column=1)

    entrada_a = tk.Entry(parent)
    tk.Label(parent, text="a:").grid(row=7, column=0)
    entrada_a.grid(row=7, column=1)

    entrada_b = tk.Entry(parent)
    tk.Label(parent, text="b:").grid(row=8, column=0)
    entrada_b.grid(row=8, column=1)

# Funções de interface
def simulador(x):
    global m, frame_entrada, frame_saida
    def processar_1():
        global l, ni, nf, a, b, m
        try:
            l = float(entrada_l.get())
            ni = float(entrada_ni.get())
            nf = float(entrada_nf.get())
            a = float(entrada_a.get())
            b = float(entrada_b.get())

            eij = ei_j()
            eiev = ei_ev()
            efj = ef_j()
            efev = ef_ev()
            E = e_f()
            lam = lamb()
            f = freq()
            vi = vi()
            vf = vf()
            ci = ci()
            cf = cf()
            ki = ki()
            kf = kf()
            area = sqrt(2/l)
            i = probabilidade(a, b, ni, l)
            f = probabilidade(a, b, nf, l)

            text_area_saida.delete(1.0, tk.END)
            text_area_saida.insert(tk.END, f"Resultados:\n----------------\nMassa: {m} kg\n"
                                           f"Largura da caixa (L): {l} m\n"
                                           f"n inicial da partícula (Ni): {ni}\n"
                                           f"n final da partícula (Nf): {nf}\n"
                                           f"a: {a}\n"
                                           f"b: {b}\n"f"ψ{ni} (x) = {area:.4e} . sen({(ki):.4e}.x)\n"
                                  f"ψ{nf} (x) = {area:.4e} . sen({(kf):.4e}.x)\n"
                                  f"E{ni} = {eij:.4e} J ou {eiev:.4e} eV\n"
                                  f"E{nf} = {efj:.4e} J ou {efev:.4e} eV\n"
                                  f"Efoton = {E:.4e} eV\n"
                                  f"Comprimento de onda do fóton = {lam:.4e} m\n"
                                  f"Frequência do fóton = {f:.4e} Hz\n"
                                  f"Velocidade da partícula:\nn = {ni}: v = {vi:.4e} m/s\tn = {nf}: v = {vf:.4e} m/s\n"
                                  f"Comprimento de onda de De Broglie:\nn = {ni}: ƛ = {ci:.4e} m\tn = {nf}: ƛ = {cf:.4e} m\n"
                                  f"A probabilidade da partícula estar entre {a:.4e} e {b:.4e} no nível {ni} é de {i*100:.3f} %\n"
                                  f"A probabilidade da partícula estar entre {a:.4e} e {b:.4e} no nível {nf} é de {f*100:.3f} %\n")
            # plot_wave_functions(a, b, ni, nf, l)
            # plot_probability_distribution(a, b, ni, nf, l)
        except ValueError:
            messagebox.showerror("Erro de Entrada", "Por favor, insira valores numéricos válidos.")

    def graficos():
        print("Gráficos")

    def simular():
        print("Simulação")

    if (x == 1):
        limpar_frames()
        frame_entrada = tk.Frame(janela)
        frame_saida = tk.Frame(janela) 
    else:
        simulador = tk.Tk()
        simulador.title("Simulador")
        frame_entrada = tk.Frame(simulador)
        frame_saida = tk.Frame(simulador)
        simulador.mainloop()
    
    m = 1.67 * (10 ** -27)
    frame_entrada = tk.Frame(janela)
    frame_entrada.pack()

    tk.Label(frame_entrada, text="Introdução\n").grid(row=0, column=1)

    m_opcao = tk.StringVar(frame_entrada, "1")
    m_opcao.trace("w", lambda *args: m_option(m_opcao.get()))
    tk.Radiobutton(frame_entrada, text="Próton", variable=m_opcao, value="1").grid(row=2, column=0, padx=10, pady=6)
    tk.Radiobutton(frame_entrada, text="Elétron", variable=m_opcao, value="2").grid(row=2, column=1, padx=10, pady=5)
    labels_and_entries(frame_entrada)

    # Arrumar os botões
    # Colocar os gráficos
    tk.Button(frame_entrada, text="Gráficos", command=processar_1).grid(row=9, column=0, columnspan=1)

    # Colocar a simulação 
    tk.Button(frame_entrada, text="Simular", command=simular).grid(row=9, column=1, columnspan=1)

    tk.Button(frame_entrada, text="Processar", command=graficos).grid(row=9, column=2, columnspan=1)
    #

    frame_saida.pack()
    text_area_saida = tk.Text(frame_saida, width=50, height=10)
    text_area_saida.pack()

# def simulador_2():
#     global m, frame_entrada, frame_saida
#     def processar_1():
#         global l, ni, nf, a, b, m
#         try:
#             l = float(entrada_l.get())
#             ni = float(entrada_ni.get())
#             nf = float(entrada_nf.get())
#             a = float(entrada_a.get())
#             b = float(entrada_b.get())

#             eij = ei_j()
#             eiev = ei_ev()
#             efj = ef_j()
#             efev = ef_ev()
#             E = e_f()
#             lam = lamb()
#             f = freq()
#             vi = vi()
#             vf = vf()
#             ci = ci()
#             cf = cf()
#             ki = ki()
#             kf = kf()
#             area = sqrt(2/l)
#             i = probabilidade(a, b, ni, l)
#             f = probabilidade(a, b, nf, l)

#             text_area_saida.delete(1.0, tk.END)
#             text_area_saida.insert(tk.END, f"Resultados:\n----------------\nMassa: {m} kg\n"
#                                            f"Largura da caixa (L): {l} m\n"
#                                            f"n inicial da partícula (Ni): {ni}\n"
#                                            f"n final da partícula (Nf): {nf}\n"
#                                            f"a: {a}\n"
#                                            f"b: {b}\n"f"ψ{ni} (x) = {area:.4e} . sen({(ki):.4e}.x)\n"
#                                   f"ψ{nf} (x) = {area:.4e} . sen({(kf):.4e}.x)\n"
#                                   f"E{ni} = {eij:.4e} J ou {eiev:.4e} eV\n"
#                                   f"E{nf} = {efj:.4e} J ou {efev:.4e} eV\n"
#                                   f"Efoton = {E:.4e} eV\n"
#                                   f"Comprimento de onda do fóton = {lam:.4e} m\n"
#                                   f"Frequência do fóton = {f:.4e} Hz\n"
#                                   f"Velocidade da partícula:\nn = {ni}: v = {vi:.4e} m/s\tn = {nf}: v = {vf:.4e} m/s\n"
#                                   f"Comprimento de onda de De Broglie:\nn = {ni}: ƛ = {ci:.4e} m\tn = {nf}: ƛ = {cf:.4e} m\n"
#                                   f"A probabilidade da partícula estar entre {a:.4e} e {b:.4e} no nível {ni} é de {i*100:.3f} %\n"
#                                   f"A probabilidade da partícula estar entre {a:.4e} e {b:.4e} no nível {nf} é de {f*100:.3f} %\n")
#             # plot_wave_functions(a, b, ni, nf, l)
#             # plot_probability_distribution(a, b, ni, nf, l)
#         except ValueError:
#             messagebox.showerror("Erro de Entrada", "Por favor, insira valores numéricos válidos.")

#     def graficos():
#         print("Gráficos")

#     def simular():
#         print("Simulação")

#     m = 1.67 * (10 ** -27)

#     simulador = tk.Tk()
#     simulador.title("Simulador")

#     frame_entrada = tk.Frame(simulador)
#     frame_entrada.pack()

#     tk.Label(frame_entrada, text="Introdução\n").grid(row=0, column=1)

#     m_opcao = tk.StringVar(frame_entrada, "1")
#     m_opcao.trace("w", lambda *args: m_option(m_opcao.get()))
#     tk.Radiobutton(frame_entrada, text="Próton", variable=m_opcao, value="1").grid(row=2, column=0, padx=10, pady=6)
#     tk.Radiobutton(frame_entrada, text="Elétron", variable=m_opcao, value="2").grid(row=2, column=1, padx=10, pady=5)
#     labels_and_entries(frame_entrada)

#     # Arrumar os botões
#     # Colocar os gráficos
#     tk.Button(frame_entrada, text="Gráficos", command=processar_1).grid(row=9, column=0, columnspan=1)

#     # Colocar a simulação 
#     tk.Button(frame_entrada, text="Simular", command=simular).grid(row=9, column=1, columnspan=1)

#     tk.Button(frame_entrada, text="Processar", command=graficos).grid(row=9, column=2, columnspan=1)
#     #

#     frame_saida = tk.Frame(simulador)
#     frame_saida.pack()
#     text_area_saida = tk.Text(frame_saida, width=50, height=10)
#     text_area_saida.pack()
#     simulador.mainloop()

# Função para a caixa 1D
def caixa_1d(x):
    global m, frame_entrada, frame_saida
    def processar_2():
        global a, k, xp, l, m, n
        try:
            a = float(entrada_a.get())
            k = float(entrada_k.get())
            xp = float(entrada_xp.get())

            l = l_func()
            n = n_func()
            p = probalidade_2()
            # prob = 2 / l * (sin(n * pi * xp) ** 2)
            text_area_saida.delete(1.0, tk.END)
            text_area_saida.insert(tk.END, f"Entradas:\n----------------\nMassa: {m} kg\n"
                                           f"A: {a} m\nk: {k} m^-1\nPosição de x (que multiplique L): {xp}\n"
                                           "----------------\nResultados:\n----------------\n"
                                           f"Largura da caixa: {l:.4e} m\n"
                                           f"Número quântico da partícula: {n}\n"
                                           f"Probabilidade de encontrar a partícula na posição {xp}: {p:.3}\n")
        except ValueError as e:
            messagebox.showerror("Erro de Entrada", "Por favor, insira valores numéricos válidos.")
    if (x == 1):
        limpar_frames()
        frame_entrada = tk.Frame(janela)
        frame_saida = tk.Frame(janela) 
    else:
        caixa = tk.Tk()
        caixa.title("Caixa 1D")
        frame_entrada = tk.Frame(caixa)
        frame_saida = tk.Frame(caixa)
        caixa.mainloop()
    
    m = 1.67 * (10 ** -27)
    frame_entrada.pack()

    tk.Label(frame_entrada, text="Função de onda (no SI) de uma partícula \nconfinada em um poço de \npotencial infinito unidimencional é dada por:").grid(row=0, column=0)
    tk.Label(frame_entrada, text=f"\nψ(x) = A sin (k * x) \n").grid(row=0, column=1)

    m_opcao = tk.StringVar(value="1")
    m_opcao.trace("w", lambda *args: m_option(m_opcao.get()))
    tk.Radiobutton(frame_entrada, text="Próton", variable=m_opcao, value="1").grid(row=1, column=0, padx=10, pady=5)
    tk.Radiobutton(frame_entrada, text="Elétron", variable=m_opcao, value="2").grid(row=1, column=1, padx=10, pady=5)
    label_a = tk.Label(frame_entrada, text="A em m:")
    label_a.grid(row=2, column=0)
    entrada_a = tk.Entry(frame_entrada)
    entrada_a.grid(row=2, column=1)
    label_k = tk.Label(frame_entrada, text="k em m:")
    label_k.grid(row=3, column=0)
    entrada_k = tk.Entry(frame_entrada)
    entrada_k.grid(row=3, column=1)
    label_xp = tk.Label(frame_entrada, text="Posição de x (que multiplique L):")
    label_xp.grid(row=4, column=0)
    entrada_xp = tk.Entry(frame_entrada)
    entrada_xp.grid(row=4, column=1)
    botao_submit = tk.Button(frame_entrada, text="Processar", command=processar_2)
    botao_submit.grid(row=5, column=0, columnspan=2)
    frame_saida.pack()
    text_area_saida = tk.Text(frame_saida, width=50, height=10)
    text_area_saida.pack()

# def caixa_1d_2():
#     global m, frame_entrada, frame_saida
#     def processar_2():
#         global a, k, xp, l, m, n
#         try:
#             a = float(entrada_a.get())
#             k = float(entrada_k.get())
#             xp = float(entrada_xp.get())

#             l = l_func()
#             n = n_func()
#             p = probalidade_2()
#             # prob = 2 / l * (sin(n * pi * xp) ** 2)
#             text_area_saida.delete(1.0, tk.END)
#             text_area_saida.insert(tk.END, f"Entradas:\n----------------\nMassa: {m} kg\n"
#                                            f"A: {a} m\nk: {k} m^-1\nPosição de x (que multiplique L): {xp}\n"
#                                            "----------------\nResultados:\n----------------\n"
#                                            f"Largura da caixa: {l:.4e} m\n"
#                                            f"Número quântico da partícula: {n}\n"
#                                            f"Probabilidade de encontrar a partícula na posição {xp}: {p:.3}\n")
#         except ValueError as e:
#             messagebox.showerror("Erro de Entrada", "Por favor, insira valores numéricos válidos.")
#     m = 1.67 * (10 ** -27)
#     caixa = tk.Tk()
#     caixa.title("Simulador")
#     frame_entrada = tk.Frame(caixa)
#     frame_entrada.pack()

#     tk.Label(frame_entrada, text="Função de onda (no SI) de uma partícula \nconfinada em um poço de \npotencial infinito unidimencional é dada por:").grid(row=0, column=0)
#     tk.Label(frame_entrada, text=f"\nψ(x) = A sin (k * x) \n").grid(row=0, column=1)

#     m_opcao = tk.StringVar(value="1")
#     m_opcao.trace("w", lambda *args: m_option(m_opcao.get()))
#     tk.Radiobutton(frame_entrada, text="Próton", variable=m_opcao, value="1").grid(row=1, column=0, padx=10, pady=5)
#     tk.Radiobutton(frame_entrada, text="Elétron", variable=m_opcao, value="2").grid(row=1, column=1, padx=10, pady=5)
#     label_a = tk.Label(frame_entrada, text="A em m:")
#     label_a.grid(row=2, column=0)
#     entrada_a = tk.Entry(frame_entrada)
#     entrada_a.grid(row=2, column=1)
#     label_k = tk.Label(frame_entrada, text="k em m:")
#     label_k.grid(row=3, column=0)
#     entrada_k = tk.Entry(frame_entrada)
#     entrada_k.grid(row=3, column=1)
#     label_xp = tk.Label(frame_entrada, text="Posição de x (que multiplique L):")
#     label_xp.grid(row=4, column=0)
#     entrada_xp = tk.Entry(frame_entrada)
#     entrada_xp.grid(row=4, column=1)
#     botao_submit = tk.Button(frame_entrada, text="Processar", command=processar_2)
#     botao_submit.grid(row=5, column=0, columnspan=2)
#     frame_saida = tk.Frame(caixa)
#     frame_saida.pack()
#     text_area_saida = tk.Text(frame_saida, width=50, height=10)
#     text_area_saida.pack()
#     caixa.mainloop()

def conversor_1():
    def converter_1():
        print("Processar")
    conversor = tk.Tk()
    conversor.title("m / cm / nm / km / mm / um / pm")
    def selected_option(entrada, saida):
        print("Entrada:", entrada)
        print("Saída:", saida)

    option_entry = ["Opção 1", "Opção 2", "Opção 3"]
    option_out = ["Opção 1", "Opção 2", "Opção 3"]

    # StringVar to hold the selected option
    selected_value = tk.StringVar()
    selected_value.set(option_entry[0])  # Set initial selection
    # StringVar to hold the selected option
    selected_value1 = tk.StringVar()
    selected_value1.set(option_out[0])  # Set initial selection

    # Create the dropdown menu
    dropdown = tk.OptionMenu(conversor, selected_value, *option_entry, command=selected_option)
    dropdown = tk.OptionMenu(conversor, selected_value1, *option_out, command=selected_option)
    # Add the dropdown menu to the window
    dropdown.pack()
    
    conversor.mainloop()

def conversor_2():
    def converter_2():
        print("Processar")
    conversor = tk.Tk()
    conversor.title("eV / J / cal / kcal / BTU / kWh / Wh")

     
    conversor.mainloop()

def conversor_3():
    def converter_3():
        print("Processar")
    conversor = tk.Tk()
    conversor.title("Hz / kHz / MHz / GHz / THz")

   
    conversor.mainloop()
# def create_animation_window():
#     new_window = tk.Toplevel(janela)
#     fig, ax = plt.subplots()
#     x=np.linspace(0,1,1000)

# Janela principal
def main():
    menu = tk.Menu(janela)
    # menu.add_command(label="Simulador", command=simulador)
    # menu.add_command(label="Caixa 1D", command=caixa_1d)
    # menu.add_command(label="Conversores", command=conversores)

    submenu_simulador = tk.Menu(menu, tearoff=0)
    submenu_simulador.add_command(label="Normal", command=simulador(1))
    submenu_simulador.add_command(label="Pop-Up", command=simulador(2))  # Função lambda simples

    menu.add_cascade(label="Simulador", menu=submenu_simulador)

    submenu_caixa = tk.Menu(menu, tearoff=0)
    submenu_caixa.add_command(label="Normal", command=caixa_1d(1))
    submenu_caixa.add_command(label="Pop-Up", command=caixa_1d(2))  # Função lambda simples

    menu.add_cascade(label="Caixa 1D", menu=submenu_caixa)

    # # Janela secundária
    submenu_conversores = tk.Menu(menu, tearoff=0)
    submenu_conversores.add_command(label="m / cm / nm / km / mm / um / pm", command=conversor_1)
    submenu_conversores.add_command(label="eV / J / cal / kcal / BTU / kWh / Wh", command=conversor_2)  
    submenu_conversores.add_command(label="Hz / kHz / MHz / GHz / THz", command=conversor_3)

    menu.add_cascade(label="Conversores", menu=submenu_conversores)

    # janela.config(menu=menu)
    # janela.mainloop()
    menu.add_separator()  # Adiciona uma linha separadora
    menu.add_command(label="Sair", command=janela.quit)
    janela.config(menu=menu)
    janela.mainloop()

main()
