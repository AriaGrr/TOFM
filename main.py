# Turma 725, Equipe 3:
# Marjorie Luize Martins Costa, RA: 24223084-5;
# Matheus Ferreira de Freitas, RA: 24123080-4;
# Henrique Hodel Babler, RA: 24123079-6

# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣼⣿⣿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⣷⣿⣇⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⢰⣾⣿⣿⡟⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⣿⣿⣿⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⣠⣿⡿⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠿⣿⣧⣀⣤⣠⣄⣤⣀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⢰⣶⣿⡟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢙⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀⠀
# ⠀⢠⣼⣿⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠂⠁⠀⠘⣿⣿⡇⠀⠀⠀⠀
# ⢀⣸⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⢩⠁⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀
# ⣿⣿⣯⠀⠀⠀⣤⣴⣶⣶⣤⣦⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣴⣶⣴⣦⡆⣼⣿⢘⠀⠀⠀⢰⣿⣿⡇⠀⠀⠀⠀
# ⣿⣿⣟⠐⠀⣿⡏⠉⠈⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⠏⠉⢩⣿⣿⣿⣿⡿⢆⣰⣿⣿⣿⣿⣿⣷⣷⣀⠀⠀
# ⣿⣿⣿⢤⠀⣿⣷⣤⣤⣿⣿⣿⣿⢨⣶⣴⣶⣶⣶⣶⣶⣶⣿⣿⣦⣤⣼⣿⣿⣿⣏⡓⠸⣿⡟⡛⠛⠛⣛⣿⣿⣿⠀⢀
# ⠀⢸⣿⣿⣶⡹⡏⠀⠁⠈⠀⠹⠿⠘⣿⣧⣀⣀⣠⣀⣼⣿⠃⠿⠏⠩⢡⣼⣿⡿⠟⣿⣿⠋⠅⠀⠀⠀⠀⠀⢹⣿⣿⣿
# ⠀⠈⢹⣿⣶⡇⠀⠀⠀⠀⠀⠀⠀⠀⠙⣻⣿⣿⣿⣿⣟⠉⠀⠀⠀⢰⣶⣿⣿⡇⠄⠈⣿⠁⠀⠀⠀⠀⠀⠀⢸⣿⣿⡇
# ⠀⠀⠘⠛⣿⣿⣧⢅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣼⣿⠒⠛⠇⠀⠀⠀⠤⡀⠀⠀⠀⠀⠀⢸⣿⣿⡇
# ⠀⠀⠀⠀⠉⠿⢿⣿⣶⣐⣆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡏⢉⣁⠀⢨⣄⢀⠀⠀⢁⣀⣀⣀⣀⣀⣸⣿⣿⣷
# ⠀⠀⠀⠀⠀⠀⠘⠛⣿⣿⣿⣽⣿⣤⠤⡤⣤⢤⣤⡤⣤⣤⣤⣷⣿⡇⠀⠸⠀⠛⢻⣿⣴⣤⡄⣐⢸⣦⣿⣿⣿⣿⠛⠻
# ⠀⠀⠀⠀⠀⠀⠀⠀⠉⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⠽⣄⣀⣸⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠈⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠠⣶⣿⡟⣛⠉⠛⡟⣛⣛⠛⠛⠛⠛⠛⣻⢻⣿⣿⣿⣶⣾⣶⣿⣿⣿⡋⠋⠙⠋⠙⠋⠁⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⡟⠀⢈⣿⠇⠂⠀⠀⠀⠀⠀⠀⠀⠛⣿⣿⣿⣿⠿⠿⠿⠿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠉⢿⣷⣷⣾⣿⠀⠀⠀⢒⣶⣶⡖⡢⠀⠀⣿⣿⣿⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢻⣿⣿⣦⡄⠀⢰⣿⣿⣇⢱⠀⣤⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⡿⠏⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠛⠀⠀⠘⠛⠛⠛⠃⠀⠀⠀⠀⠀

import os
import tkinter as tk
from scipy.integrate import quad
from math import sqrt, pi, sin
from tkinter import messagebox
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation




# Configuração inicial: Janela principal e declaração de variáveis e constantes
janela = tk.Tk()
janela.title("Menu")

frame_entrada = None
frame_saida = None

# Variáveis Gerais
hj = 6.626 * (10 ** -34)  # Constante de Planck em J.s
hev = 4.136 * (10 ** -15)  # Constante de Planck em eV.s
c = 3 * 10 ** 8  # Velocidade da luz no vácuo em m/s

l = 0  # Largura da caixa
ni = 0  # n inicial da partícula
nf = 0  # n final da partícula
n = 0 

# Probabilidade de encontrar a partícula entre a e b P(a <= x <= b) = 2/l * sin(n * pi * x / l) ** 2 (Integral)

a = 0  # Limite inferior para probabilidade
b = 0  # Limite superior para probabilidade
A = 0  # Amplitude em metros
k = 0  # Número de onda em metros
xp = 0  # Posição x em metros

# Variável de controle de massa
m = 1.67 * (10 ** -27)  # Inicializando como próton

# Funções

# Furtos 

# Função para calcular a energia inicial
def ei_j():
    ei = ni ** 2 * (hj ** 2) / (8 * m * l ** 2)
    return ei

# Função para calcular a energia final
def ef_j():
    ef = nf ** 2 * (hj ** 2) / (8 * m * l ** 2)
    return ef

# Função para calcular a energia final em eV
def e_f():
    efoton = abs(ef_ev() - ei_ev())
    return efoton

# Função para calcular a energia inicial em eV
def ei_ev():
    eij = ei_j() / (1.602 * (10 ** -19))
    return eij

# Função para calcular a energia final em eV
def ef_ev():
    efj = ef_j() / (1.602 * (10 ** -19))
    return efj

# Função para calcular o comprimento de onda
def lamb():
    lamb = (hev * 3 * (10 ** 8)) / e_f()
    return lamb

# Função para calcular a frequência
def freq():
    f = e_f() / hev
    return f

# Função para calcular a velocidade inicial
def vi():
    vi = sqrt((2 * ei_j()) / m)
    return vi

# Função para calcular a velocidade final
def vf():
    vf = sqrt((2 * ef_j()) / m)
    return vf

# Função para calcular o comprimento de onda inicial
def ci():
    ci = 2 * l / ni
    return ci

# Função para calcular o comprimento de onda final
def cf():
    cf = 2 * l / nf
    return cf

# Função para calcular o número de onda inicial
def ki():
    ki = ni * pi / l
    return ki

# Função para calcular o número de onda final
def kf():
    kf = nf * pi / l
    return kf

# Função para calcular a amplitude
def l():
    l = 2 / a ** 2
    return l

# Função para calcular o número de onda
def n():
    n = round((k * l) / pi)
    return n

# Verificar 
def probabilidade(a, b, ni, l):
    integrand = lambda x: 2 / l * sin((ni * pi * x) / l) ** 2
    result, _ = quad(integrand, a, b)
    return result

def probalidade_2():
    prob = 2 / l * (sin(n * pi * xp) ** 2)
    return prob

# Função para limpar frames
def limpar_frames():
    global frame_entrada, frame_saida
    if frame_entrada:
        frame_entrada.destroy()
    if frame_saida:
        frame_saida.destroy()

def m_option(opcao):
    global m
    if opcao == "1":
        m = 1.67 * (10 ** -27)  # massa do próton
    elif opcao == "2":
        m = 9.11 * (10 ** -31)  # massa do elétron
    else:
        print("Opção inválida. Tente novamente.")


# Esta função foi criada para consolidar e simplificar a criação de labels e entradas(mta label slc)

def labels_and_entries(parent, process_func):
    global entrada_l, entrada_ni, entrada_nf, entrada_a, entrada_b
    entrada_l = tk.Entry(parent)

    tk.Label(parent, text="Largura da caixa (L) em m:").grid(row=3, column=0)
    entrada_l.grid(row=3, column=1)

    entrada_ni = tk.Entry(parent)
    tk.Label(parent, text="n inicial da particula (Ni):").grid(row=4, column=0)
    entrada_ni.grid(row=4, column=1)

    entrada_nf = tk.Entry(parent)
    tk.Label(parent, text="n final da particula (Nf):").grid(row=5, column=0)
    entrada_nf.grid(row=5, column=1)

    tk.Label(parent, text="Dados para probabilidade:\n P(a <= x <= b)").grid(row=6, column=1)

    entrada_a = tk.Entry(parent)
    tk.Label(parent, text="a:").grid(row=7, column=0)
    entrada_a.grid(row=7, column=1)

    entrada_b = tk.Entry(parent)
    tk.Label(parent, text="b:").grid(row=8, column=0)
    entrada_b.grid(row=8, column=1)

    tk.Button(parent, text="Processar", command=process_func).grid(row=9, column=0, columnspan=2)

#Mudei a atualização da variável global 'm', que representa a massa
#da partícula,corrigi para garantir que os valor seja atualizado 
#adequadamente conforme a escolha nos Radiobuttons. 

#Implementei um rastreador ('trace') na variável StringVar associada, 
#que dispara a função m_option sempre que a seleção muda, só pra 
#garantir que a massa fique com a opção certa. 

#Além disso, eu limpei o codigo pra melhorar a organização, desculpa 
#se agluma função de anotação foi excluida como alguma não faziam #nada eu as removi

# Funções de interface
def simulador():
    global m, frame_entrada, frame_saida
    def processar_1():
        global l, ni, nf, a, b
        try:
            l = float(entrada_l.get())
            ni = float(entrada_ni.get())
            nf = float(entrada_nf.get())
            a = float(entrada_a.get())
            b = float(entrada_b.get())

            eij = ei_j()
            eiev = ei_ev()
            efj = ef_j()
            efev = ef_ev()
            E = e_f()
            lam = lamb()
            f = freq()
            vi = vi()
            vf = vf()
            ci = ci()
            cf = cf()
            ki = ki()
            kf = kf()
            area = sqrt(2/l)
            i = probabilidade(a, b, ni, l)
            f = probabilidade(a, b, nf, l)

            text_area_saida.delete(1.0, tk.END)
            text_area_saida.insert(tk.END, f"Resultados:\n----------------\nMassa: {m} kg\n"
                                           f"Largura da caixa (L): {l} m\n"
                                           f"n inicial da partícula (Ni): {ni}\n"
                                           f"n final da partícula (Nf): {nf}\n"
                                           f"a: {a}\n"
                                           f"b: {b}\n"f"ψ{ni} (x) = {area:.4e} . sen({(ki):.4e}.x)\n"
                                  f"ψ{nf} (x) = {area:.4e} . sen({(kf):.4e}.x)\n"
                                  f"E{ni} = {eij:.4e} J ou {eiev:.4e} eV\n"
                                  f"E{nf} = {efj:.4e} J ou {efev:.4e} eV\n"
                                  f"Efoton = {E:.4e} eV\n"
                                  f"Comprimento de onda do fóton = {lam:.4e} m\n"
                                  f"Frequência do fóton = {f:.4e} Hz\n"
                                  f"Velocidade da partícula:\nn = {ni}: v = {vi:.4e} m/s\tn = {nf}: v = {vf:.4e} m/s\n"
                                  f"Comprimento de onda de De Broglie:\nn = {ni}: ƛ = {ci:.4e} m\tn = {nf}: ƛ = {cf:.4e} m\n"
                                  f"A probabilidade da partícula estar entre {a:.4e} e {b:.4e} no nível {ni} é de {i*100:.3f} %\n"
                                  f"A probabilidade da partícula estar entre {a:.4e} e {b:.4e} no nível {nf} é de {f*100:.3f} %\n")
            # plot_wave_functions(a, b, ni, nf, l)
            # plot_probability_distribution(a, b, ni, nf, l)
        except ValueError:
            messagebox.showerror("Erro de Entrada", "Por favor, insira valores numéricos válidos.")
    m = 1.67 * (10 ** -27)
    limpar_frames()
    frame_entrada = tk.Frame(janela)
    frame_entrada.pack()

    tk.Label(frame_entrada, text="Introdução\n").grid(row=0, column=1)

    m_opcao = tk.StringVar(frame_entrada, "1")
    m_opcao.trace("w", lambda *args: m_option(m_opcao.get()))
    tk.Radiobutton(frame_entrada, text="Próton", variable=m_opcao, value="1").grid(row=2, column=0, padx=10, pady=6)
    tk.Radiobutton(frame_entrada, text="Elétron", variable=m_opcao, value="2").grid(row=2, column=1, padx=10, pady=5)
    labels_and_entries(frame_entrada, processar_1)
    frame_saida = tk.Frame(janela)
    frame_saida.pack()
    text_area_saida = tk.Text(frame_saida, width=50, height=10)
    text_area_saida.pack()

#Removi duplicações desnecessárias dos widgets, como a recriação de Radiobuttons e Frames

#Mudei a atualização da variável global 'm', que representa a massa da partícula

#Implementei um rastreador ('trace') na variável StringVar associada, que dispara a função
#m_option sempre que a seleção muda

#organizei o código para melhorar a clareza

#Limpei a estrutura dos frames e dos widgets, removendo blocos de código comentados que não eram
#utilizados

#Atualizei e simplifiquei a função processar_2 para coletar entradas, limpar a área de saída, e 
#preparar para exibição dos resultados


# Função para a caixa 1D
def caixa_1d():
    global m, frame_entrada, frame_saida
    def processar_2():
        global A, k, xp, l, m
        try:
            A = float(entrada_a.get())
            k = float(entrada_k.get())
            xp = float(entrada_xp.get())

            l = l()
            n = n()
            prob = probalidade_2()

            text_area_saida.delete(1.0, tk.END)
            text_area_saida.insert(tk.END, f"Entradas:\n----------------\nMassa: {m} kg\n"
                                           f"A: {A} m\nk: {k} m^-1\nPosição de x (que multiplique L): {xp}\n\n"
                                           "----------------\nResultados:\n----------------\n"
                                           f"Largura da caixa: {l:.4e} m\n"
                                           f"Número quântico da partícula: {n}\n"
                                           f"Probabilidade de encontrar a partícula na posição {xp}: {prob:.4e}\n")
        except ValueError as e:
            messagebox.showerror("Erro de Entrada", "Por favor, insira valores numéricos válidos.")
    m = 1.67 * (10 ** -27)
    limpar_frames()
    frame_entrada = tk.Frame(janela)
    frame_entrada.pack()

    tk.Label(frame_entrada, text="Função de onda (no SI) de uma partícula \nconfinada em um poço de \npotencial infinito unidimencional é dada por:").grid(row=0, column=0)
    tk.Label(frame_entrada, text=f"\nψ(x) = A sin (k * x) \n").grid(row=0, column=1)

    m_opcao = tk.StringVar(value="1")
    m_opcao.trace("w", lambda *args: m_option(m_opcao.get()))
    tk.Radiobutton(frame_entrada, text="Próton", variable=m_opcao, value="1").grid(row=1, column=0, padx=10, pady=5)
    tk.Radiobutton(frame_entrada, text="Elétron", variable=m_opcao, value="2").grid(row=1, column=1, padx=10, pady=5)
    label_a = tk.Label(frame_entrada, text="A em m:")
    label_a.grid(row=2, column=0)
    entrada_a = tk.Entry(frame_entrada)
    entrada_a.grid(row=2, column=1)
    label_k = tk.Label(frame_entrada, text="k em m:")
    label_k.grid(row=3, column=0)
    entrada_k = tk.Entry(frame_entrada)
    entrada_k.grid(row=3, column=1)
    label_xp = tk.Label(frame_entrada, text="Posição de x (que multiplique L):")
    label_xp.grid(row=4, column=0)
    entrada_xp = tk.Entry(frame_entrada)
    entrada_xp.grid(row=4, column=1)
    botao_submit = tk.Button(frame_entrada, text="Processar", command=processar_2)
    botao_submit.grid(row=5, column=0, columnspan=2)
    frame_saida = tk.Frame(janela)
    frame_saida.pack()
    text_area_saida = tk.Text(frame_saida, width=50, height=10)
    text_area_saida.pack()


# def create_animation_window():
#     new_window = tk.Toplevel(janela)
#     fig, ax = plt.subplots()
#     x=np.linspace(0,1,1000)
    






# Janela principal
menu = tk.Menu(janela)
menu.add_command(label="Simulador", command=simulador)
menu.add_command(label="Caixa 1D", command=caixa_1d)
menu.add_separator()  # Adiciona uma linha separadora
menu.add_command(label="Sair", command=janela.quit)
janela.config(menu=menu)
janela.mainloop()
# # Janela secundária
# submenu = tk.Menu(menu, tearoff=0)
# submenu.add_command(label="Teste", command=teste3)
# submenu.add_command(label="Teste 1", command=lambda: print("Teste 1"))  # Função lambda simples
# submenu.add_command(label="Teste 2", command=lambda: print("Teste 2"))

# menu.add_cascade(label="Funções", menu=submenu)

janela.config(menu=menu)
janela.mainloop()



